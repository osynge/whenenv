import os, os.path
import logging, logging.config
import sys
import subprocess
import datetime
import time
import optparse

import string
import uuid
import re
import base64
import shutil

from jjobrun.chroot_package_installer import ChrootPackageInstallerRedhat ,ChrootPackageInstallerDebian


def subphandling(cmd,timeout = 10):   
    log = logging.getLogger("sub")
    process = subprocess.Popen([cmd], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    processRc = None
    handleprocess = True
    counter = 0
    stdout = ''
    stderr = ''
    while handleprocess:
        counter += 1
        time.sleep(1)
        cout,cerr = process.communicate()
        stdout += cout
        stderr += stderr
        log.info(cout)
        log.warning(cerr)
        process.poll()
        processRc = process.returncode
        if processRc != None:
            break
        if counter == timeout:
            os.kill(process.pid, signal.SIGQUIT)
        if counter > timeout:
            os.kill(process.pid, signal.SIGKILL)
            processRc = -9
            break
    return (processRc,stdout,stderr)

#!/usr/bin/env python

"""This spawns a sub-shell (bash) and gives the user interactive control. The
entire shell session is logged to a file called script.log. This behaves much
like the classic BSD command 'script'.

./script.py [-a] [-c command] {logfilename}

    logfilename : This is the name of the log file. Default is script.log.
    -a : Append to log file. Default is to overwrite log file.
    -c : spawn command. Default is to spawn the sh shell.

Example:

    This will start a bash shell and append to the log named my_session.log:

        ./script.py -a -c bash my_session.log

"""

import os, sys, time, getopt
import signal, fcntl, termios, struct
import traceback
import pexpect

global_pexpect_instance = None # Used by signal handler

transtbl = string.maketrans(
          'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
          'ABCEGHJKLMNPRSTVWXYZabcdefghijkl'
        )
def exit_with_usage():

    print globals()['__doc__']
    os._exit(1)

def sigwinch_passthrough (sig, data):

    # Check for buggy platforms (see pexpect.setwinsize()).
    if 'TIOCGWINSZ' in dir(termios):
        TIOCGWINSZ = termios.TIOCGWINSZ
    else:
        TIOCGWINSZ = 1074295912 # assume
    s = struct.pack ("HHHH", 0, 0, 0, 0)
    a = struct.unpack ('HHHH', fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ , s))
    global global_pexpect_instance
    global_pexpect_instance.setwinsize(a[0],a[1])




def jumpstrart():
    #if __name__ == "__main__":
    try:
        main()
    except SystemExit, e:
        raise e
    except Exception, e:
        print "ERROR"
        print 'sssssss',str(e)
        traceback.print_exc()
        os._exit(1)



def lsb_release():
    log = logging.getLogger("lsb_release")
    cmd = "lsb_release -a"
    processRc,stdout,stderr = subphandling(cmd,timeout = 10)
    if processRc != 0:
        log.error("'%s' returned an error" % (cmd))
        return None
    magicLines = ["Distributor ID",
        "Description",
        "Release",
        "Codename"]
    output = {}
    for line in stdout.split('\n'):
        splitline = line.strip().split(':')
        if len(splitline) <= 1:
            continue
        if splitline[0] in magicLines:
            value = splitline[1].strip()
            output[splitline[0]] = value
    log.info(output)
    
    return output

class runnershell:
    def __init__(self, chrootCmd, env):
        self.log = logging.getLogger("runnershell")
        self.chrootCmd = chrootCmd
        match_prompt = uuid.uuid1()
        self.prompt = base64.b32encode(str(match_prompt).replace('-', '').decode('hex')).rstrip('=').translate(transtbl)
        self.env = env
        self.p = None
    
    
    def setPrompt(self):
        
        self.p.send("PS1=%s\n" % (self.prompt))
        self.p.flush()
        match_one =  uuid.uuid1()
        bashvar_one = base64.b32encode(str(match_one).replace('-', '').decode('hex')).rstrip('=').translate(transtbl)
        sent = 'echo %s${PS1}%s\n' % (bashvar_one,bashvar_one)
        index = self.p.expect ([self.prompt,pexpect.EOF, pexpect.TIMEOUT],timeout=10)
        self.p.send("export PS1\n")
        self.p.flush()
        sent = 'echo %s${PS1}%s\n' % (bashvar_one,bashvar_one)
        self.p.send(sent)
        done = False
        while done == False:
            index = self.p.expect ([bashvar_one, 
                    pexpect.EOF, 
                    pexpect.TIMEOUT],timeout=50)
            if index == 0:
                second = self.p.expect ([bashvar_one, 
                    pexpect.EOF, 
                    pexpect.TIMEOUT],timeout=50)
                if second == 0:
                    cleaned = self.p.before.strip()
                    done = True
                    if cleaned == self.prompt:
                        self.log.error("priompt set goot %s" % (cleaned))
                    else:
                        self.log.error("Somethign went wrong entering chroot %s=%s" % (index,self.chrootCmd))
                        
        
        if index == 0:
            self.log.info("prompt Ok")
    
    def initialise(self):
        if None != self.p:
            self.finalise()
        self.log.info("Initialising:%s" % (self.chrootCmd))
        self.p = pexpect.spawn(self.chrootCmd)
        self.p.send("stty -echo\n")
        self.p.flush()
        self.setPrompt()
        return True
    def finalise(self):
        self.log.info("finalising")
        if self.p.isalive() == True:
            self.p.send("\nexit 0\n")
            self.p.flush()
        if self.p.isalive() == True:
            self.p.send("\nexit 0\n")
            self.p.flush()
        
        if self.p.isalive() == True:
            self.log.info("waiting")
            self.p.wait()
        exitstatus = self.p.exitstatus
        self.p = None
        self.log.info("finalising done")
        return exitstatus

    def setEnv(self,env):
        env_ignored = set(["PATH","SHLVL","OLDPWD","PS1"])
        for enviroment in env.keys():
            if enviroment in env_ignored:
                continue
            cmd = '%s="%s"\n' % (enviroment,env[enviroment])
            self.log.info("setEnv %s" %(cmd))
            self.p.send(cmd)
            self.p.flush()
        return True

    def getEnv(self):
        self.log.info("getEnv")
        env_ignored = set(["PATH","SHLVL","OLDPWD",])

        reuslts = {}
        self.p.send("\n")
        self.p.flush()
        self.p.send("export\n\n")
        self.p.flush()
        match = 'declare -x '
        
        souldloop = True
        foundEnv = {}
        while souldloop == True:
            exitstatus = self.p.exitstatus
            if exitstatus != None:
                self.log.info("exitstatus=%s" % (exitstatus))
                self.log.info("self.p.env=%s" % self.p.env)
                break
            index = self.p.expect ([match,pexpect.EOF, pexpect.TIMEOUT],timeout=100)
            self.log.critical("index=%s" %(index))
            if index == 0:
                imput = self.p.before.strip()
                if len(imput) == 0:
                    continue
                secondlevel = self.p.expect (['"\r\n',pexpect.EOF, pexpect.TIMEOUT],timeout=2)
                imput = self.p.before
                self.log.info("secondlevel=%s=%s" % (secondlevel,imput))
                if secondlevel == 0:
                    imput = self.p.before
                    striped = imput.strip()
                    if len (striped) == 0:
                        continue
                    #self.log.info("secondlevel=%s" % (striped))
                    splitline = striped.split('="')
                    self.log.info("splitline=%s" % (splitline))
                    if len(splitline) < 2:
                        
                        continue
                    key = splitline[0]
                    value = splitline[1]
                    if key in env_ignored:
                        continue
                    foundEnv[key] = value
            elif index == 1:
                break
            elif index == 2:
                break
            elif index == 3:
                self.log.info("timeout")
                break
            else:
                self.log.info("error=%s" % (index))
        self.log.debug("getEnv returns=%s" % (foundEnv))
        return foundEnv
        
    def runscript(self,script):
        self.log.info("runscript(%s)" % (script))
        # Now load script
        fp = open(script)
        self.setPrompt()
        match_one =  uuid.uuid1()
        bashvar_one = base64.b32encode(str(match_one).replace('-', '').decode('hex')).rstrip('=').translate(transtbl)
        self.p.flush()
        self.p.send("\nset -e\n")
        self.p.send("\nset -x\n")
        self.p.flush()
        self.setPrompt()
        for line in fp:
            self.p.send(line)
        sent = 'echo %s${?}%s\n' % (bashvar_one,bashvar_one)
        self.log.info("sent='%s'" % (sent))
        self.p.send(sent)
        
        souldloop = True
        output = 0
        ready = False
        state = 0
        returnCode = None
        
        nextlinecount = 3
        timeouts = 0
        while souldloop == True:
            index = self.p.expect ([bashvar_one,self.prompt,pexpect.EOF, pexpect.TIMEOUT],timeout=5)
            self.log.debug("indexxx=%s" % (index))
            
            if index == 0:
                secondIndex = self.p.expect ([bashvar_one,self.prompt,pexpect.EOF, pexpect.TIMEOUT],timeout=5)
                
                if secondIndex == 0:
                    cleaned = self.p.before.strip()
                    
                    self.log.info("Got script RC value=%s" % (cleaned))
                    output = int(cleaned)
                    break 
                else:
                    self.log.error("Failed retriving RC")
            if index == 1:
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
                timeouts = 0
                #self.p.send('echo %s="${?}"\n' % (bashvar_one))
            if index == 2:
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
                self.log.error("Unexpected EOF")
                exitstatus = self.p.exitstatus
                if exitstatus != None:
                    output = exitstatus
                else:
                    output = 255
                self.log.error("Quit")
                return output
                    
                
            if index == 3:
                self.log.debug("TimeOut")
                
                timeouts = timeouts +1
                if timeouts > 100:
                    self.log.error("timedout")
                    return output
            if index == 4:
                timeouts = 0
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
            
            if index == 5:
                timeouts = 0
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
        return output
            
class jobPartRun:
    def __init__(self, shell="/bin/bash"):
        self.log = logging.getLogger("jobPartRun")
        self.shell = shell
        
        
        
    def do_something(self,prefix):
        #imput = self.p.read()
        imput = self.p.before
        striped = imput.strip()
        if len(striped) > 0:
            self.log.info("%s=%s" % (prefix,imput.strip()))
        
    def endofline(self):
        #imput = self.p.read()
        imput = self.p.before
        striped = imput.strip()
        if len(striped) > 0:
            self.log.info("endofline=%s" % (imput.strip()))
        #infomration = self.p.read()
    
    
    def getArtifacts(self,jobpart,env):
        if not "artifacts" in jobpart.keys():
            self.log.debug("No artifacts in chroot script so no chroot artifacts")
            return True
            RawartifactsList = list(jobpart["artifacts"])
        if not "CHROOT" in env.keys():
            self.log.debug("No CHROOT variable, so no chroot artifacts")
            return True
        prefix =  env["CHROOT"]
        RawartifactsList = list(jobpart["artifacts"])
        rc = 0
        for artifact in RawartifactsList:
            directory = os.path.dirname(artifact)
            src = "%s/%s" %( prefix,artifact)
            dest = artifact
            self.log.info("Copying directory=%s,src=%s,dest=%s" % (directory,src,dest))
            shutil.copyfile(src, dest)
        return True
            
    def packagesDebain(self,jobpart,env):
        self.log.debug("packagesScientific(%s,%s)" % (jobpart,env))
        depnedacylist = []
        if "shell" in jobpart.keys():
            
            if "dependancies" in jobpart["shell"].keys():
                
                if "Debian" in jobpart["shell"]["dependancies"].keys():
                    self.log.info("foundthe answer")
                    depnedacylist = list(jobpart["shell"]["dependancies"]["Debian"])
        if len(depnedacylist) == 0:
            return True
        
        match_prompt = uuid.uuid1()
        prompt = str(match_prompt)
        packagesmissing = []
        alreadyinstalled = []
        chrootdir = env['CHROOT']
        cmd = "/usr/sbin/chroot %s" % (chrootdir)
        pi = ChrootPackageInstallerDebian(command = cmd,enviroment = env)
        initok = pi.initialise()
        if  initok == False:
            return False
        initok = pi.updatePackages()
        if  initok == False:
            return False
        initok = pi.installPackages(depnedacylist)
        if  initok == False:
            return False
        return True
        
    def packagesScientific(self,jobpart,env):
        self.log.debug("packagesScientific(%s,%s)" % (jobpart,env))
        depnedacylist = []
        if "shell" in jobpart.keys():
            
            if "dependancies" in jobpart["shell"].keys():
                
                if "Debian" in jobpart["shell"]["dependancies"].keys():
                    self.log.info("foundthe answer")
                    depnedacylist = list(jobpart["shell"]["dependancies"]["Debian"])
        if len(depnedacylist) == 0:
            return True
        
        match_prompt = uuid.uuid1()
        prompt = str(match_prompt)
        packagesmissing = []
        alreadyinstalled = []
        chrootdir = env['CHROOT']
        cmd = "/usr/sbin/chroot %s" % (chrootdir)
        pi = ChrootPackageInstallerRedhat(cmd,env)
        initok = pi.initialise()
        if  initok == False:
            return False
        initok = pi.updatePackages()
        if  initok == False:
            return False
        initok = pi.installPackages(depnedacylist)
        if  initok == False:
            return False
        return True
        
        
        
    def packages(self,jobpart,env):
        release =  lsb_release()
        
         
        if release["Distributor ID"] == "Debian":
            self.packagesDebain(jobpart,env)
        
        if release["Distributor ID"] == "Scientific":
            self.packagesScientific(jobpart,env)
          
                    
        
        
    def executabingo(self,jobpart,env = {}):
        self.log.error("executabingo")
        inputenv = os.environ
        inputenv.update(env)
        output = {"rc" :  255 , "env" : {}}
        knownKeys = set(inputenv)
        env_ignored = set(["PATH","SHLVL","OLDPWD",]).union(set(env.keys()))
        
        if not "flags" in jobpart.keys():
            self.log.error("no flags specified")
            return output
        
        if not "script" in jobpart.keys():
            sel.log.error("no script specified")
            return output
        self.packages(jobpart,env)
        command = "/bin/bash"
        allfliages =  jobpart["flags"]
        self.log.error("flags=%s" % (allfliages))
        if "chroot" in allfliages:
            if not "CHROOT" in inputenv.keys():
                self.log.error("no CHROOT enviroment_valiable set")
                return output
            chootdir = inputenv["CHROOT"]
            command = "%s %s /bin/bash"  % ("/usr/sbin/chroot" , chootdir)
        self.log.error("command=%s" % (command))
        #chroot /workspace/docbook-production/chroot/ /bin/bash
        sr = runnershell(command,env)
        rc = sr.initialise()
        if rc != True:
            sel.log.error("failed to init CHROOT")
            return output
        rc = sr.setEnv(env)
        if rc != True:
            sel.log.error("failed to set env in CHROOT")
            return output
        # Now load script
        script = "%s/%s" % (os.path.dirname(os.path.realpath(__file__)),jobpart["script"])
        initialEnv = sr.getEnv()
        #self.log.info("initialEnv '%s'" % (initialEnv))
        rc = sr.runscript(script)
        self.log.info("runscript rc '%s'" % (rc))
        foundEnv = {}
        if rc == 0:
            self.log.info("Updating env")
            afterEnv = sr.getEnv()
            self.log.info("initialEnv '%s'" % (initialEnv))
            self.log.info("afterEnv '%s'" % (afterEnv))
            keysInitial = set(initialEnv.keys()).difference()
            keysFinal = set(afterEnv.keys()).difference()
            keysnew = keysFinal.difference(keysInitial)
            
            for key in keysnew:
                value = afterEnv[key]
                self.log.info("Exported '%s=%s'" % (key,value))
                foundEnv[key] = value
        returnCode = sr.finalise()
        self.log.info("finalise rc '%s'" % (returnCode))
        return {"rc" :  rc , "env" : foundEnv}

def runJob (jobname):
    log = logging.getLogger("runJob")
    mappings = {
        "GenChroot.SL-6X" : ["transfer/GenChroot.SL-6X.sh"],
        #"vmcatcher-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
        #    "transfer/vmcatcher-scientific-6-prod.sh",
        #    "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-trunk-test" :["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher-scientific-6-trunk-test.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-prod-test" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher-scientific-6-prod-test.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        
        "vmcatcher_eventHndlExpl_ON-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher_eventHndlExpl_ON-scientific-6-prod-part-01.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher_eventHndlExpl_ON-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher_eventHndlExpl_ON-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-scientific-6-trunk" :["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/smimeX509validation-scientific-6-trunk-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/smimeX509validation-scientific-6-prod-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "grid-virt-sort-scientific-6-prod" : [ "transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/grid-virt-sort-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "hepixvmitrust-scientific-6-prod" : [ "transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/hepixvmitrust-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-scientific-6-trunk" : [ "transfer/chroot-scientific-6-buildup-trunk.sh" ,
            "transfer/vmcaster-scientific-6-trunk-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "dirvacua-scientific-6-trunk" : [ "transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/dirvacua-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcaster-scientific-6-prod-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "chrootbuilder-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/chrootbuilder-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-debian-wheezy-prod" : ["transfer/vmcaster-debian-wheezy-prod-part-01.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-02.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-03.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-04.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-05.sh"],
        "hepixvmitrust-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/hepixvmitrust-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "repo-scientific" : ["transfer/repo-scientific.sh"],
        "hepixvmitrust-debian-wheezy-prod" : ["transfer/hepixvmitrust-debian-wheezy-prod-part-01.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-02.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-03.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-04.sh"],
        "grid-virt-sort-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/grid-virt-sort-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "GenChroot.debian-wheezy" : ["transfer/GenChroot.debian-wheezy-part-01.sh",
            "transfer/GenChroot.debian-wheezy-part-02.sh",
            "transfer/GenChroot.debian-wheezy-part-03.sh",
            "transfer/GenChroot.debian-wheezy-part-04.sh"],
        #"dirvacua-debian-wheezy-prod" : ["transfer/dirvacua-debian-wheezy-prod-part-01.sh",
        #    "transfer/dirvacua-debian-wheezy-prod-part-02.sh",
        #    "transfer/dirvacua-debian-wheezy-prod-part-03.sh",
        #    "transfer/dirvacua-debian-wheezy-prod-part-04.sh",
        #    "transfer/dirvacua-debian-wheezy-prod-part-05.sh"],
        "dirvacua-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/dirvacua-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "chroot-imagelist-update" : ["transfer/chroot-imagelist-update.sh"],
        "chroot-scientific-6-repo" : ["transfer/chroot-scientific-6-repo.sh"],
        "publish-image-overlay" : ["transfer/publish-image-overlay-debian.sh"],
        
        
        "docbook-production" : [{   "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
        
            {   "script" : "transfer/docbook-production.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["make", "subversion","openjdk-6-jre-lib","libservlet2.5-java", "openjdk-6-jre","openjdk-6-jre-headless", "fop", "xsltproc","docbook-xml","docbook-xsl" ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "vmcatcher-debian-wheezy-prod" : [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/vmcatcher-debian-wheezy-prod-part-03.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["git", "python","rpm","make", "python-setuptools","python-m2crypto", ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "smimeX509validation-debian-wheezy-prod": [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/smimeX509validation-debian-wheezy-prod-part-04.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["git", "python","rpm","make", "python-setuptools","python-m2crypto", ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "grid-virt-sort-debian-wheezy-prod-deb": [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/smimeX509validation-debian-wheezy-prod-part-04.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["git", "python","git-buildpackage","devscripts", "python-all",  "python-setuptools","python-m2crypto",] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "grid-virt-sort-debian-wheezy-prod": [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/grid-virt-sort-debian-wheezy-prod-part-03.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["subversion", "python","rpm","make" ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "chroot-test-vmcatcher-scientific-6-prod" : [{"script" : "transfer/chroot-scientific-6-buildup-prod.sh"},
            {   "script" : "transfer/chroot-test-vmcatcher-scientific-6-prod.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Scientific" : ["org-desy-grid-virt-sort-release" ,"hepixvmitrust","git", "python","rpm","make","python-setuptools","m2crypto" ] },
                    },
                "artifacts" : ["artifacts.tgz"],
                "flags" : ["chroot"],
            },
            {"script" : "transfer/chroot-scientific-6-teardown.sh"}],
        "vmcatcher-scientific-6-prod" : [{"script" : "transfer/chroot-scientific-6-buildup-prod.sh"},
                {"script" : "transfer/vmcatcher-scientific-6-prod.sh"},
                {"script" : "transfer/chroot-scientific-6-teardown.sh"}],
        "dirvacua-debian-wheezy-prod" : [{"script" : "transfer/chroot-debian-wheezy-buildup.sh"},
                {   "script" : "transfer/dirvacua-debian-wheezy-prod-chrooted.sh",
                    "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["subversion", "python","rpm","make","git", "python-setuptools","python-m2crypto" ] },
                    },
                "artifacts" : ["artifacts.tgz"],
                "flags" : ["chroot"],
                },
                {"script" : "transfer/chroot-debian-wheezy-teardown.sh"}],
        "chrootbuilder-debian-wheezy-prod": [{"script" : "transfer/chroot-debian-wheezy-buildup.sh"},
                {   "script" : "transfer/chrootbuilder-debian-wheezy-prod.sh",
                    "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["subversion", "python","rpm","make","git", "python-setuptools","python-m2crypto" ] },
                    },
                "artifacts" : ["artifacts.tgz"],
                "flags" : ["chroot"],
                },
                {"script" : "transfer/chroot-debian-wheezy-teardown.sh"}],
        }
    if not jobname in mappings.keys():
        log.error("job is not mapped '%s' " % (jobname) )
        return 1
    enviroment = {}
    for jobpart in mappings[jobname]:
        jobDetails = {}
        if type(jobpart) == str:
            
            log.info("running jobpart '%s' " % (jobpart) )
            jobDetails["script"] = jobpart 
        if type(jobpart) == dict:
            jobDetails.update(jobpart)

        foo = jobPartRun()
        #requires = set(jobDetails["requires"])
        log.info("running jobDetails '%s' " % (jobDetails))
        if not "flags" in jobDetails.keys():
            jobDetails["flags"] = []
        resetMap = foo.executabingo(jobDetails,enviroment)
        if resetMap["env"] != 0:
            enviroment.update(resetMap["env"])
            log.debug("Job Enviroment='%s'" % (enviroment) )
        if resetMap["rc"] != 0:
            log.error("cmd '%s' returned '%s'." % (jobDetails,resetMap["rc"]))
            return resetMap["rc"]
        else:
            if "artifacts" in jobDetails.keys():
                rc = foo.getArtifacts(jobDetails,enviroment)
                if rc != True:
                    return rc
            else:
                log.info("No artifacts '%s' " % (jobDetails))
    return 0
        
        




def main():
    reload(sys)
    sys.setdefaultencoding('utf-8')
    log = logging.getLogger("main")
    p = optparse.OptionParser(version = "%prog " + "0.0.1")
    p.add_option('--verbose', action ='count',help='Change global log level, increasing log output.', metavar='LOGFILE')
    p.add_option('--quiet', action ='count',help='Change global log level, decreasing log output.', metavar='LOGFILE')
    p.add_option('--log-config', action ='store',help='Logfile configuration file, (overrides command line).', metavar='LOGFILE')
    p.add_option('--logcfg', action ='store',help='Logfile configuration file.', metavar='LOGCFGFILE')
    
    options, arguments = p.parse_args()
    if options.logcfg:
        if os.path.isfile(str(options.logfile)):
            logging.config.fileConfig(options.logfile)
        else:
            logging.basicConfig(level=logging.INFO)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.logfile))
            sys.exit(1)
    else:
        logging.basicConfig(level=logging.INFO)
    outputDict = None
    logFile = None
    
    if 'VMCHNDL_ON_LOG_CONF' in os.environ:
        logFile = os.environ['VMCHNDL_ON_LOG_CONF']
    if 'CHROOT' in os.environ:
        log.error("CHROOT in environ")
        sys.exit(1)
    
    # Set up log file
    LoggingLevel = logging.WARNING
    LoggingLevelCounter = 2
    if options.verbose:
        LoggingLevelCounter = LoggingLevelCounter - options.verbose
        if options.verbose == 1:
            LoggingLevel = logging.INFO
        if options.verbose == 2:
            LoggingLevel = logging.DEBUG
    if options.quiet:
        LoggingLevelCounter = LoggingLevelCounter + options.quiet
    if LoggingLevelCounter <= 0:
        LoggingLevel = logging.DEBUG
    if LoggingLevelCounter == 1:
        LoggingLevel = logging.INFO
    if LoggingLevelCounter == 2:
        LoggingLevel = logging.WARNING
    if LoggingLevelCounter == 3:
        LoggingLevel = logging.ERROR
    if LoggingLevelCounter == 4:
        LoggingLevel = logging.FATAL
    if LoggingLevelCounter >= 5:
        LoggingLevel = logging.CRITICAL
    
    if options.log_config:
        logFile = options.log_config
    if logFile != None:
        if os.path.isfile(str(options.log_config)):
            logging.config.fileConfig(options.log_config)
        else:
            logging.basicConfig(level=LoggingLevel)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.log_config))
            sys.exit(1)
    else:
        logging.basicConfig(level=LoggingLevel)
    log = logging.getLogger("main")

    jobname = None
    if 'JOB_NAME' in os.environ:
        jobname=os.environ['JOB_NAME']
    else:
        log.error("No JOB_NAME Enviroment variable set")
        sys.exit(2)
    log.info("JOB_NAME=%s" % jobname )
    
    rc = runJob(jobname)
    if rc != 0:
        log.error("runJob returned '%s'" % (rc) )
        sys.exit(2)
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
