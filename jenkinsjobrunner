import os, os.path
import logging, logging.config
import sys
import subprocess
import datetime
import time
import optparse

import string
import uuid
import re
import base64

def subphandling(cmd,timeout = 10):   
    log = logging.getLogger("sub")
    process = subprocess.Popen([cmd], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    processRc = None
    handleprocess = True
    counter = 0
    stdout = ''
    stderr = ''
    while handleprocess:
        counter += 1
        time.sleep(1)
        cout,cerr = process.communicate()
        stdout += cout
        stderr += stderr
        log.info(cout)
        log.warning(cerr)
        process.poll()
        processRc = process.returncode
        if processRc != None:
            break
        if counter == timeout:
            os.kill(process.pid, signal.SIGQUIT)
        if counter > timeout:
            os.kill(process.pid, signal.SIGKILL)
            processRc = -9
            break
    return (processRc,stdout,stderr)

#!/usr/bin/env python

"""This spawns a sub-shell (bash) and gives the user interactive control. The
entire shell session is logged to a file called script.log. This behaves much
like the classic BSD command 'script'.

./script.py [-a] [-c command] {logfilename}

    logfilename : This is the name of the log file. Default is script.log.
    -a : Append to log file. Default is to overwrite log file.
    -c : spawn command. Default is to spawn the sh shell.

Example:

    This will start a bash shell and append to the log named my_session.log:

        ./script.py -a -c bash my_session.log

"""

import os, sys, time, getopt
import signal, fcntl, termios, struct
import traceback
import pexpect

global_pexpect_instance = None # Used by signal handler

transtbl = string.maketrans(
          'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
          'ABCEGHJKLMNPRSTVWXYZabcdefghijkl'
        )
def exit_with_usage():

    print globals()['__doc__']
    os._exit(1)

def oldmain():

    ######################################################################
    # Parse the options, arguments, get ready, etc.
    ######################################################################
    try:
        optlist, args = getopt.getopt(sys.argv[1:], 'h?ac:', ['help','h','?'])
    except Exception, e:
        print str(e)
        exit_with_usage()
    options = dict(optlist)
    if len(args) > 1:
        exit_with_usage()
        
    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:
        print "Help:"
        exit_with_usage()

    if len(args) == 1:
        script_filename = args[0]
    else:
        script_filename = "script.log"
    if '-a' in options:
        fout = file (script_filename, "ab")
    else:
        fout = file (script_filename, "wb")
    if '-c' in options:
        command = options['-c']
    else:
        command = "sh"

    # Begin log with date/time in the form CCCCyymm.hhmmss
    fout.write ('# %4d%02d%02d.%02d%02d%02d \n' % time.localtime()[:-3])
    
    ######################################################################
    # Start the interactive session
    ######################################################################
    p = pexpect.spawn(command)
    p.logfile = fout
    global global_pexpect_instance
    global_pexpect_instance = p
    signal.signal(signal.SIGWINCH, sigwinch_passthrough)

    print "Script recording started. Type ^] (ASCII 29) to escape from the script shell."
    p.interact(chr(29))
    fout.close()
    return 0

def sigwinch_passthrough (sig, data):

    # Check for buggy platforms (see pexpect.setwinsize()).
    if 'TIOCGWINSZ' in dir(termios):
        TIOCGWINSZ = termios.TIOCGWINSZ
    else:
        TIOCGWINSZ = 1074295912 # assume
    s = struct.pack ("HHHH", 0, 0, 0, 0)
    a = struct.unpack ('HHHH', fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ , s))
    global global_pexpect_instance
    global_pexpect_instance.setwinsize(a[0],a[1])




def jumpstrart():
    #if __name__ == "__main__":
    try:
        main()
    except SystemExit, e:
        raise e
    except Exception, e:
        print "ERROR"
        print 'sssssss',str(e)
        traceback.print_exc()
        os._exit(1)

class runnershell:
    def __init__(self, shell="/bin/bash"):
        self.log = logging.getLogger("runnershell")
        self.shell = shell
        
        
        
    def do_something(self,prefix):
        #imput = self.p.read()
        imput = self.p.before
        striped = imput.strip()
        if len(striped) > 0:
            self.log.info("%s=%s" % (prefix,imput.strip()))
        
    def endofline(self):
        #imput = self.p.read()
        imput = self.p.before
        striped = imput.strip()
        if len(striped) > 0:
            self.log.info("endofline=%s" % (imput.strip()))
        #infomration = self.p.read()

    def packages(self,jobpart):
        depnedacylist = []
        if "shell" in jobpart.keys():
            
            if "dependancies" in jobpart["shell"].keys():
                
                if "Debian" in jobpart["shell"]["dependancies"].keys():
                    self.log.info("foundthe answer")
                    depnedacylist = list(jobpart["shell"]["dependancies"]["Debian"])
        if len(depnedacylist) == 0:
            return True
        
        #script_filename = "foo"
        #if os.path.isfile(script_filename):
        #    fout = file (script_filename, "ab")
        #else:
        #    fout = file (script_filename, "wb")
        #self.p.logfile = fout
        match_prompt = uuid.uuid1()
        prompt = str(match_prompt)
        packagesmissing = []
        alreadyinstalled = []
        for package in depnedacylist:
            self.log.info("todo=%s" % (package))
            cmd = "/usr/sbin/chroot chroot /usr/bin/dpkg-query -W --showformat='${Status}\n' %s\n" % (package)
            p = pexpect.spawn(cmd)
            p.send("PS1=%s\n" % (prompt)) 
            p.send(cmd)
            
            done = False
            while done == False:
                
                index = p.expect (["install ok installed",
                    "dpkg-query: no packages found matching %s" % (package),
                    prompt, 
                    pexpect.EOF, 
                    pexpect.TIMEOUT, 
                    '\r\n'],timeout=500)
                self.log.info("result ddxd=%s`" % (index))
                if index == 0:
                    done = True
                    alreadyinstalled.append(package)
                if index == 1:
                    packagesmissing.append(package)
                    done = True
                if index == 3:
                    done = True
            p.send("exit 0\n")
            exitstatus = p.exitstatus
            if exitstatus == None:
                p.wait()
                exitstatus = p.exitstatus
            
                
        for package in depnedacylist:
            #self.log.info("ssssssssssssssssssssssssssssssssss")
            cmd = "/usr/sbin/chroot chroot /usr/bin/apt-get install -y %s\n" % (package)
            self.log.info(cmd)
            p = pexpect.spawn(cmd)
            p.send("PS1=%s\n" % (prompt)) 
            p.send(cmd)
            done = False
            while done == False:
                index = p.expect (["Do you want to continue",
                    prompt,
                    "%s is already the newest version." % (package),
                    "additional disk space will be used", 
                    pexpect.EOF, 
                    pexpect.TIMEOUT,
                    'Reading package lists',
                    'The following NEW packages will be installed',
                    'Get:',
                    'Selecting previously unselected package',
                    'Fetched',
                    'Unpacking',
                    'Setting',
                    'Processing triggers for '],
                    timeout=500)
                self.log.debug("aptitude insstall=%s" % (index))
                if index == 0:
                    p.send("Y\n")
                    
                if index >= 6:
                    imput = p.before
                    striped = imput.strip()
                    if len(striped) > 0:
                        self.log.info(imput.strip())
                if index in [2,4]:
                    done = True
                if index == 3:
                    p.send("Y\n")
                if index == 1:
                    p.send(cmd)
            if p.isalive() == True:
                p.send("exit 0\n")
            if p.isalive() == True:
                p.wait()
                
                    
        
        
    def executabingo(self,jobpart,env = {}):
        self.packages(jobpart)
        inputenv = os.environ
        inputenv.update(env)
        output = {"rc" :  255 , "env" : {}}
        knownKeys = set(inputenv)
        env_ignored = set(["PATH","SHLVL","OLDPWD",]).union(set(env.keys()))
        command = "/bin/bash"
        
        
        
        
        
        
        
        if "shell" in jobpart.keys():
            chootdir = "chroot"
            if "CHROOT" in inputenv.keys():
                chootdir = inputenv["CHROOT"]
            command = "%s %s /bin/bash"  % ("/usr/sbin/chroot" , chootdir)

        #chroot /workspace/docbook-production/chroot/ /bin/bash

        
        self.p = pexpect.spawn(command)
        #script_filename = "foo"
        #if os.path.isfile(script_filename):
        #    fout = file (script_filename, "ab")
        #else:
        #    fout = file (script_filename, "wb")
        #self.p.logfile = fout
        match_prompt = uuid.uuid1()
        prompt = str(match_prompt)
        self.p.send("PS1=%s\n" % (prompt)) 
        index = self.p.expect ([prompt, pexpect.EOF, pexpect.TIMEOUT, '\r\n'])
        self.p.send("stty -echo\n")
        index = self.p.expect ([prompt, pexpect.EOF, pexpect.TIMEOUT, '\r\n'])
        
        # Now load enviroment
        
        for enviroment in env.keys():
            self.p.send('%s="%s"\n' % (enviroment,env[enviroment]))
            index = self.p.expect ([prompt, pexpect.EOF, pexpect.TIMEOUT, '\r\n'])
        
        # Now load build deps
        
        self.packages(jobpart)

        
        # Now load script
        script = "%s/%s" % (os.path.dirname(os.path.realpath(__file__)),jobpart["script"])
        fp = open(script)
        

        match_one =  uuid.uuid1()
        bashvar_one = base64.b32encode(str(match_one).replace('-', '').decode('hex')).rstrip('=').translate(transtbl)
        match_two =  uuid.uuid1()
        bashvar_two = base64.b32encode(str(match_two).replace('-', '').decode('hex')).rstrip('=').translate(transtbl)
        
        
        
        
        self.p.send("%s=%s\n" % (bashvar_one,match_one))
        index = self.p.expect ([prompt, pexpect.EOF, pexpect.TIMEOUT, '\r\n'])
        self.p.send("%s=%s\n" % (bashvar_two,match_two))
        index = self.p.expect ([prompt, pexpect.EOF, pexpect.TIMEOUT, '\r\n'])
        #self.p.send("set -x\n")
        #index = self.p.expect ([prompt, pexpect.EOF, pexpect.TIMEOUT, '\r\n'])
        
        commandstack = []
        for line in fp:
            self.p.send(line)
           
        
        self.p.send("echo ${%s}=${?}\n" % (bashvar_one))
        
        self.p.send("\n")
        self.souldloop = True
        ready = False
        state = 0
        returnCode = None
        
        nextlinecount = 3
        timeouts = 0
        while self.souldloop == True:
            index = self.p.expect ([prompt,'%s=.*\r\n' % (match_one),pexpect.EOF, pexpect.TIMEOUT, 'Unpacking', '\r\n','\n'],timeout=500)
            self.log.debug("indexxx=%s" % (index))
            if index == 0:
                timeouts = 0
            if index == 1:
                timeouts = 0
                after = self.p.after.split('\n')
                #print self.p.after
                #print dir(self.p.after)
                SplitLine = after[0].strip().split('=')
                #print SplitLine
                if len(SplitLine) < 2:
                    self.log.error("Failed retriving RC")
                    return output
                returnCode = int(SplitLine[1])
                self.log.debug("scriptrc=%s" % (returnCode))
                break
            if index == 2:
                
                self.log.error("Unexpected EOF")
                exitstatus = self.p.exitstatus
                if exitstatus != None:
                    output["rc"] = exitstatus
                else:
                    output["rc"] = 255
                self.log.error("Quit")
                return output
                    
                
            if index == 3:
                self.log.error("TimeOut")
                self.p.send("\n")
                timeouts = timeouts +1
                if timeouts > 100:
                    self.log.error("timedout")
                    return output
            if index == 4:
                timeouts = 0
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
            
            if index == 5:
                timeouts = 0
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
            
        self.p.send("export\n")
        self.p.send("echo ${%s}=${?}\n" % (bashvar_two))
        self.souldloop = True
        foundEnv = {}
        while self.souldloop == True:
            exitstatus = self.p.exitstatus
            if exitstatus != None:
                self.log.info("exitstatus=%s" % (exitstatus))
                self.log.info(self.p.env)
                break
            index = self.p.expect ([prompt,'%s.*\r\n' % (match_two),pexpect.EOF, pexpect.TIMEOUT, '\r\n'],timeout=200)
            if index == 1:
                after = self.p.after.split('\n')
                self.log.info("sdfsdfsdf=%s,%s" % (after[0].strip(),index))
                break
            
            if index == 4:
                imput = self.p.before
                striped = imput.strip()
                if len (striped) == 0:
                    continue
                if "declare -x " != (striped[:11]):
                    continue
                regdelexp = re.compile('=')
                shellline = striped[11:]
                matches = regdelexp.search(shellline)
                if matches == None:
                    continue
                key = shellline[:matches.start()]
                value = shellline[matches.end():][1:-1]
                if key in env_ignored:
                    continue
                if key in knownKeys:
                    if inputenv[key] != value:
                        self.log.info("Ignoring variable change %s=%s','%s" % (key,inputenv[key] , value))
                    continue
                
                foundEnv[key] = value
        
        if self.p.isalive() == True:
            self.p.send("exit 0\n")
        if self.p.isalive() == True:
            index = self.p.expect ([prompt,pexpect.EOF, pexpect.TIMEOUT, '\r\n'],timeout=2)
            
        if self.p.isalive() == True:
            self.p.wait()
        exitstatus = self.p.exitstatus
        return {"rc" :  returnCode , "env" : foundEnv}

def runJob (jobname):
    log = logging.getLogger("runJob")
    mappings = {
        "GenChroot.SL-6X" : ["transfer/GenChroot.SL-6X.sh"],
        "vmcatcher-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-trunk-test" :["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher-scientific-6-trunk-test.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-prod-test" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher-scientific-6-prod-test.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-debian-wheezy-prod" :["transfer/chroot-debian-wheezy-buildup.sh",
            "transfer/vmcatcher-debian-wheezy-prod-part-02.sh",
            "transfer/vmcatcher-debian-wheezy-prod-part-03.sh",
            "transfer/chroot-debian-wheezy-teardown.sh"],
        "vmcatcher_eventHndlExpl_ON-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher_eventHndlExpl_ON-scientific-6-prod-part-01.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher_eventHndlExpl_ON-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher_eventHndlExpl_ON-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-scientific-6-trunk" :["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/smimeX509validation-scientific-6-trunk-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/smimeX509validation-scientific-6-prod-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "grid-virt-sort-scientific-6-prod" : [ "transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/grid-virt-sort-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "hepixvmitrust-scientific-6-prod" : [ "transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/hepixvmitrust-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-scientific-6-trunk" : [ "transfer/chroot-scientific-6-buildup-trunk.sh" ,
            "transfer/vmcaster-scientific-6-trunk-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "dirvacua-scientific-6-trunk" : [ "transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/dirvacua-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-debian-wheezy-prod" : ["transfer/chroot-debian-wheezy-buildup.sh",
            "transfer/chroot-debian-wheezy-freshen.sh",
            "transfer/smimeX509validation-debian-wheezy-prod-part-03.sh",
            "transfer/smimeX509validation-debian-wheezy-prod-part-04.sh",
            "transfer/chroot-debian-wheezy-teardown.sh"],
        "grid-virt-sort-debian-wheezy-prod" : ["transfer/chroot-debian-wheezy-buildup.sh",
            "transfer/chroot-debian-wheezy-freshen.sh",
            "transfer/grid-virt-sort-debian-wheezy-prod-part-02.sh",
            "transfer/grid-virt-sort-debian-wheezy-prod-part-03.sh",
            "transfer/chroot-debian-wheezy-teardown.sh"],
        "grid-virt-sort-debian-wheezy-prod-deb" : ["transfer/chroot-debian-wheezy-buildup.sh",
            "transfer/chroot-debian-wheezy-freshen.sh",
            "transfer/grid-virt-sort-debian-wheezy-prod-deb-dependencies.sh",
            "transfer/grid-virt-sort-debian-wheezy-prod-deb-build.sh",
            "transfer/grid-virt-sort-debian-wheezy-prod-deb-export.sh",
            "transfer/chroot-debian-wheezy-teardown.sh"],
        "vmcaster-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcaster-scientific-6-prod-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-debian-wheezy-prod" : ["transfer/vmcaster-debian-wheezy-prod-part-01.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-02.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-03.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-04.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-05.sh"],
        "hepixvmitrust-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/hepixvmitrust-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "repo-scientific" : ["transfer/repo-scientific.sh"],
        "hepixvmitrust-debian-wheezy-prod" : ["transfer/hepixvmitrust-debian-wheezy-prod-part-01.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-02.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-03.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-04.sh"],
        "grid-virt-sort-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/grid-virt-sort-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "GenChroot.debian-wheezy" : ["transfer/GenChroot.debian-wheezy-part-01.sh",
            "transfer/GenChroot.debian-wheezy-part-02.sh",
            "transfer/GenChroot.debian-wheezy-part-03.sh",
            "transfer/GenChroot.debian-wheezy-part-04.sh"],
        "dirvacua-debian-wheezy-prod" : ["transfer/dirvacua-debian-wheezy-prod-part-01.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-02.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-03.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-04.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-05.sh"],
        "dirvacua-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/dirvacua-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "chroot-imagelist-update" : ["transfer/chroot-imagelist-update.sh"],
        "chroot-scientific-6-repo" : ["transfer/chroot-scientific-6-repo.sh"],
        "publish-image-overlay" : ["transfer/publish-image-overlay-debian.sh"],
        
        
        "docbook-production" : [{   "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
        
            {   "script" : "transfer/docbook-production.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["make", "subversion", "fop", "xsltproc","docbook-xml","docbook-xsl" ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        }
    if not jobname in mappings.keys():
        log.error("job is not mapped '%s' " % (jobname) )
        return 1
    enviroment = {}
    for jobpart in mappings[jobname]:
        if type(jobpart) == str:
            log.info("running jobpart '%s' " % (jobpart) )
            script = "%s/%s" % (os.path.dirname(os.path.realpath(__file__)),jobpart)
            cmd = ". %s" % (script)
            processRc,stdout,stderr = subphandling(cmd,timeout = 360)
            log.info(" '%s' " % (processRc) )
            if processRc != 0:
                log.error("cmd '%s' returned '%s'." % (cmd,processRc) )
                return processRc
        if type(jobpart) == dict:
            foo = runnershell()
            cmd = jobpart["script"]
            #requires = set(jobpart["requires"])
            log.info("running jobpart '%s' " % (cmd))
            resetMap = foo.executabingo(jobpart,enviroment)
            if resetMap["env"] != 0:
                enviroment.update(resetMap["env"])
                log.info("Job Enviroment='%s'" % (enviroment) )
            if resetMap["rc"] != 0:
                log.error("cmd '%s' returned '%s'." % (cmd,resetMap["rc"]))
                return resetMap["rc"]
    return 0
        
        




def main():
    reload(sys)
    sys.setdefaultencoding('utf-8')
    log = logging.getLogger("main")
    p = optparse.OptionParser(version = "%prog " + "0.0.1")
    p.add_option('--verbose', action ='count',help='Change global log level, increasing log output.', metavar='LOGFILE')
    p.add_option('--quiet', action ='count',help='Change global log level, decreasing log output.', metavar='LOGFILE')
    p.add_option('--log-config', action ='store',help='Logfile configuration file, (overrides command line).', metavar='LOGFILE')
    p.add_option('--logcfg', action ='store',help='Logfile configuration file.', metavar='LOGCFGFILE')
    
    options, arguments = p.parse_args()
    if options.logcfg:
        if os.path.isfile(str(options.logfile)):
            logging.config.fileConfig(options.logfile)
        else:
            logging.basicConfig(level=logging.INFO)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.logfile))
            sys.exit(1)
    else:
        logging.basicConfig(level=logging.INFO)
    outputDict = None
    logFile = None
    
    if 'VMCHNDL_ON_LOG_CONF' in os.environ:
        logFile = os.environ['VMCHNDL_ON_LOG_CONF']
    # Set up log file
    LoggingLevel = logging.WARNING
    LoggingLevelCounter = 2
    if options.verbose:
        LoggingLevelCounter = LoggingLevelCounter - options.verbose
        if options.verbose == 1:
            LoggingLevel = logging.INFO
        if options.verbose == 2:
            LoggingLevel = logging.DEBUG
    if options.quiet:
        LoggingLevelCounter = LoggingLevelCounter + options.quiet
    if LoggingLevelCounter <= 0:
        LoggingLevel = logging.DEBUG
    if LoggingLevelCounter == 1:
        LoggingLevel = logging.INFO
    if LoggingLevelCounter == 2:
        LoggingLevel = logging.WARNING
    if LoggingLevelCounter == 3:
        LoggingLevel = logging.ERROR
    if LoggingLevelCounter == 4:
        LoggingLevel = logging.FATAL
    if LoggingLevelCounter >= 5:
        LoggingLevel = logging.CRITICAL
    
    if options.log_config:
        logFile = options.log_config
    if logFile != None:
        if os.path.isfile(str(options.log_config)):
            logging.config.fileConfig(options.log_config)
        else:
            logging.basicConfig(level=LoggingLevel)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.log_config))
            sys.exit(1)
    else:
        logging.basicConfig(level=LoggingLevel)
    log = logging.getLogger("main")

    jobname = None
    if 'JOB_NAME' in os.environ:
        jobname=os.environ['JOB_NAME']
    else:
        log.error("No JOB_NAME Enviroment variable set")
        sys.exit(2)
    log.info("JOB_NAME=%s" % jobname )
    
    rc = runJob(jobname)
    if rc != 0:
        log.error("runJob returned '%s'" % (rc) )
        sys.exit(2)
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
