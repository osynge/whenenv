import os, os.path
import logging, logging.config
import sys
import subprocess
import datetime
import time
import optparse

import string
import uuid
import re
import base64
import shutil
def subphandling(cmd,timeout = 10):   
    log = logging.getLogger("sub")
    process = subprocess.Popen([cmd], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    processRc = None
    handleprocess = True
    counter = 0
    stdout = ''
    stderr = ''
    while handleprocess:
        counter += 1
        time.sleep(1)
        cout,cerr = process.communicate()
        stdout += cout
        stderr += stderr
        log.info(cout)
        log.warning(cerr)
        process.poll()
        processRc = process.returncode
        if processRc != None:
            break
        if counter == timeout:
            os.kill(process.pid, signal.SIGQUIT)
        if counter > timeout:
            os.kill(process.pid, signal.SIGKILL)
            processRc = -9
            break
    return (processRc,stdout,stderr)

#!/usr/bin/env python

"""This spawns a sub-shell (bash) and gives the user interactive control. The
entire shell session is logged to a file called script.log. This behaves much
like the classic BSD command 'script'.

./script.py [-a] [-c command] {logfilename}

    logfilename : This is the name of the log file. Default is script.log.
    -a : Append to log file. Default is to overwrite log file.
    -c : spawn command. Default is to spawn the sh shell.

Example:

    This will start a bash shell and append to the log named my_session.log:

        ./script.py -a -c bash my_session.log

"""

import os, sys, time, getopt
import signal, fcntl, termios, struct
import traceback
import pexpect

global_pexpect_instance = None # Used by signal handler

transtbl = string.maketrans(
          'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
          'ABCEGHJKLMNPRSTVWXYZabcdefghijkl'
        )
def exit_with_usage():

    print globals()['__doc__']
    os._exit(1)

def sigwinch_passthrough (sig, data):

    # Check for buggy platforms (see pexpect.setwinsize()).
    if 'TIOCGWINSZ' in dir(termios):
        TIOCGWINSZ = termios.TIOCGWINSZ
    else:
        TIOCGWINSZ = 1074295912 # assume
    s = struct.pack ("HHHH", 0, 0, 0, 0)
    a = struct.unpack ('HHHH', fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ , s))
    global global_pexpect_instance
    global_pexpect_instance.setwinsize(a[0],a[1])




def jumpstrart():
    #if __name__ == "__main__":
    try:
        main()
    except SystemExit, e:
        raise e
    except Exception, e:
        print "ERROR"
        print 'sssssss',str(e)
        traceback.print_exc()
        os._exit(1)



def lsb_release():
    log = logging.getLogger("lsb_release")
    cmd = "lsb_release -a"
    processRc,stdout,stderr = subphandling(cmd,timeout = 10)
    if processRc != 0:
        log.error("'%s' returned an error" % (cmd))
        return None
    magicLines = ["Distributor ID",
        "Description",
        "Release",
        "Codename"]
    output = {}
    for line in stdout.split('\n'):
        splitline = line.strip().split(':')
        if len(splitline) <= 1:
            continue
        if splitline[0] in magicLines:
            value = splitline[1].strip()
            output[splitline[0]] = value
    log.info(output)
    
    return output

class ChrootPackageInstaller:
    def __init__(self, chrootCmd, env):
        self.log = logging.getLogger("ChrootPackageInstaller")
        self.chrootCmd = chrootCmd
        match_prompt = uuid.uuid1()
        self.prompt = str(match_prompt)
        self.env = env
        self.p = None
    def initialise(self):
        self.log.info("Initialising:%s" % (self.chrootCmd))
        self.p = pexpect.spawn(self.chrootCmd)
        self.p.send("\nstty -echo\n")
        self.p.flush()
        self.p.send("PS1=%s\n" % (self.prompt))
        done = False
        while done == False:
            index = self.p.expect ([self.prompt, 
                    pexpect.EOF, 
                    pexpect.TIMEOUT],timeout=500)
            if index == 0:
                done = True
            else:
                self.log.error("Somethign went wrong entering chroot")
                self.p = None
                return False
        self.p.flush()
        self.log.info("Initialising succeded")
        return True
    
        
    def updatePackages(self):
        if self.p == None:
            self.log.error("programming error no p")
            return False
        self.p.flush()
        self.p.send("rpm -qa --qf '%{NAME}\n'\n")
        done = False
        packagelist = []
        while done == False:
            index = self.p.expect ([self.prompt,
                    '\r\n', 
                    pexpect.EOF, 
                    pexpect.TIMEOUT],timeout=500)
            if index == 0:
                done = True
            elif index == 1:
                packagelist.append(self.p.before)
                self.log.debug("before=%s" % (self.p.before))
                self.log.debug("after=%s" % (self.p.after))
            else:
                self.log.error("Somethign went wrong entering chroot")
                self.p = None
                return False
        self.packagelist = packagelist
        return self.packagelist
    def installPackages(self,packagelist):
        packagesFound = self.updatePackages()
        needtoInstall = []
        for package in packagelist:
            if package in packagesFound:
                self.log.info("already installed:%s" % (package))
            else:
                self.log.info("not installed:%s" % (package))
                needtoInstall.append(package)
        for package in needtoInstall:
            self.p.flush()
            cmd = "yum install -y -q %s" % (package)
            self.log.info("running :%s" % (cmd))
            self.p.send(cmd + '\n')
            done = False
            while done == False:
                index = self.p.expect ([self.prompt,
                        '\r\n', 
                        pexpect.EOF, 
                        pexpect.TIMEOUT],timeout=500)
                if index == 0:
                    done = True
                elif index == 1:
                    self.log.info(self.p.before)
                else:
                    self.log.error("Somethign went wrong entering chroot")
                    self.p = None
                    return False
            # so now the command has executed
            self.p.flush()
            # We now need to see teh RC
            self.log.info("checking execution status")
            self.p.send("echo $?\n")
            rc = ""
            done = False
            while done == False:
                index = self.p.expect ([self.prompt,
                        '\r\n', 
                        pexpect.EOF, 
                        pexpect.TIMEOUT],timeout=500)
                if index == 0:
                    done = True
                elif index == 1:
                    
                    rc += self.p.before
                else:
                    self.log.error("Somethign went wrong entering chroot")
                    self.p = None
                    return False
            if rc != '0':
                self.log.error("rc=%s" % (rc))
                return False
        # Now we check all packages are installed
        packagesFound = self.updatePackages()
        needtoInstall = []
        for package in packagelist:
            if package in packagesFound:
                self.log.info("already installed:%s" % (package))
            else:
                self.log.info("not installed:%s" % (package))
                needtoInstall.append(package)     
        if len(needtoInstall) > 0:
            self.log.error("The following packages did not install:%s" % (needtoInstall))
            return False
        return True
        

class runnershell:
    def __init__(self, chrootCmd, env):
        self.log = logging.getLogger("ChrootPackageInstaller")
        self.chrootCmd = chrootCmd
        match_prompt = uuid.uuid1()
        self.prompt = str(match_prompt)
        self.env = env
        self.p = None
    def initialise(self):
        if None != self.p:
            self.finalise()
        self.log.info("Initialising:%s" % (self.chrootCmd))
        self.p = pexpect.spawn(self.chrootCmd)
        self.p.send("stty -echo\n")
        self.p.flush()
        self.p.send("PS1=%s\n" % (self.prompt))
        self.p.flush()
        
        self.p.send("export PS1\n")
        self.p.flush()
        self.p.send("echo PS1='${PS1}'\n")
        match = "PS1='%s.*'\r\n" % (self.prompt)
        self.log.info("Seting PS1=%s" % (self.prompt))
        index = self.p.expect ([match,self.prompt,pexpect.EOF, pexpect.TIMEOUT],timeout=10)
        
        
        if index == 0:
            self.log.info("Iniatialised Ok")
        return True
    def finalise(self):
        self.log("finalising")
        if self.p.isalive() == True:
            self.p.send("\nexit 0\n")
            self.p.flush()
        if self.p.isalive() == True:
            self.p.wait()
        exitstatus = self.p.exitstatus
        self.p = None
        return exitstatus

    def setEnv(self,env):
        
        for enviroment in env.keys():
            cmd = '%s="%s"\n' % (enviroment,env[enviroment])
            self.log.info(cmd)
            self.p.send(cmd)
            self.p.flush()
        return True

    def getEnv(self):
        self.log.info("getEnv")
        env_ignored = set(["PATH","SHLVL","OLDPWD",])

        reuslts = {}
        self.p.send("\n")
        self.p.flush()
        self.p.send("export\n")
        self.p.flush()
        match = 'declare -x '
        
        self.souldloop = True
        foundEnv = {}
        while self.souldloop == True:
            exitstatus = self.p.exitstatus
            if exitstatus != None:
                self.log.info("exitstatus=%s" % (exitstatus))
                self.log.info("self.p.env=%s" % self.p.env)
                break
            index = self.p.expect ([match,pexpect.EOF, pexpect.TIMEOUT],timeout=2)
            self.log.info("index=%s" %(index))
            if index == 0:
                imput = self.p.before
                self.log.info("watching='%s'" % (imput))
                secondlevel = self.p.expect (['"\r\n',pexpect.EOF, pexpect.TIMEOUT],timeout=2)
                imput = self.p.befor
                self.log.info("secondlevel=%s=%s" % (imput))
                if secondlevel == 0:
                    imput = self.p.before
                    elf.log.info("secondlevel=%s" % (imput))
                    imput = self.p.before
                    striped = imput.strip()
                    if len (striped) == 0:
                        continue
                    matches = regdelexp.search(shellline)
                    if matches == None:
                        continue
                    key = shellline[:matches.start()]
                    value = shellline[matches.end():][1:-1]
                    if key in env_ignored:
                        continue
                    foundEnv[key] = value
            elif index == 1:
                break
            elif index == 3:
                self.log.info("timeout")
                break
            else:
                self.log.info("error=%s" % (index))
        self.log.info("getEnv returns=%s" % (foundEnv))
        return foundEnv
        
    def runscript(self,script):
        self.log.info("runscript(%s)" % (script))
        # Now load script
        fp = open(script)
        
        match_one =  uuid.uuid1()
        bashvar_one = base64.b32encode(str(match_one).replace('-', '').decode('hex')).rstrip('=').translate(transtbl)
        self.p.flush()
        self.p.send("\nset -e\n")
        self.p.flush()
        for line in fp:
            self.p.send(line)
        self.p.send("\necho ${%s}=${?}\n" % (bashvar_one))
        self.souldloop = True
        
        ready = False
        state = 0
        returnCode = None
        
        nextlinecount = 3
        timeouts = 0
        while self.souldloop == True:
            index = self.p.expect (['%s=.*\r\n' % (match_one),self.prompt,pexpect.EOF, pexpect.TIMEOUT, 'Unpacking', '\r\n','\n'],timeout=500)
            self.log.debug("indexxx=%s" % (index))
            
            if index == 0:
                self.log.info("Got script RC")
                timeouts = 0
                after = self.p.after.split('\n')
                #print self.p.after
                #print dir(self.p.after)
                SplitLine = after[0].strip().split('=')
                #print SplitLine
                if len(SplitLine) < 2:
                    self.log.error("Failed retriving RC")
                    return output
                returnCode = int(SplitLine[1])
                self.log.debug("scriptrc=%s" % (returnCode))
                break
            if index == 1:
                timeouts = 0
            if index == 2:
                
                self.log.error("Unexpected EOF")
                exitstatus = self.p.exitstatus
                if exitstatus != None:
                    output["rc"] = exitstatus
                else:
                    output["rc"] = 255
                self.log.error("Quit")
                return output
                    
                
            if index == 3:
                self.log.error("TimeOut")
                self.p.send("\n")
                timeouts = timeouts +1
                if timeouts > 100:
                    self.log.error("timedout")
                    return output
            if index == 4:
                timeouts = 0
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
            
            if index == 5:
                timeouts = 0
                imput = self.p.before
                striped = imput.strip()
                if len(striped) > 0:
                    self.log.info(imput.strip())
            
class jobPartRun:
    def __init__(self, shell="/bin/bash"):
        self.log = logging.getLogger("jobPartRun")
        self.shell = shell
        
        
        
    def do_something(self,prefix):
        #imput = self.p.read()
        imput = self.p.before
        striped = imput.strip()
        if len(striped) > 0:
            self.log.info("%s=%s" % (prefix,imput.strip()))
        
    def endofline(self):
        #imput = self.p.read()
        imput = self.p.before
        striped = imput.strip()
        if len(striped) > 0:
            self.log.info("endofline=%s" % (imput.strip()))
        #infomration = self.p.read()
    
    
    def getArtifacts(self,jobpart,env):
        if not "artifacts" in jobpart.keys():
            self.log.debug("No artifacts in chroot script so no chroot artifacts")
            return True
            RawartifactsList = list(jobpart["artifacts"])
        if not "CHROOT" in env.keys():
            self.log.debug("No CHROOT variable, so no chroot artifacts")
            return True
        prefix =  env["CHROOT"]
        RawartifactsList = list(jobpart["artifacts"])
        rc = 0
        for artifact in RawartifactsList:
            directory = os.path.dirname(artifact)
            src = "%s/%s" %( prefix,artifact)
            dest = "artifact"
            self.log.info("Copying directory=%s,src=%s,dest=%s" % (directory,src,dest))
            shutil.copyfile(src, dest)
        return True
            
    def packagesDebain(self,jobpart,env):
        depnedacylist = []
        if "shell" in jobpart.keys():
            
            if "dependancies" in jobpart["shell"].keys():
                
                if "Debian" in jobpart["shell"]["dependancies"].keys():
                    self.log.info("foundthe answer")
                    depnedacylist = list(jobpart["shell"]["dependancies"]["Debian"])
        if len(depnedacylist) == 0:
            return True
        
        #script_filename = "foo"
        #if os.path.isfile(script_filename):
        #    fout = file (script_filename, "ab")
        #else:
        #    fout = file (script_filename, "wb")
        #self.p.logfile = fout
        match_prompt = uuid.uuid1()
        prompt = str(match_prompt)
        packagesmissing = []
        alreadyinstalled = []
        for package in depnedacylist:
            self.log.info("todo=%s" % (package))
            cmd = "/usr/sbin/chroot /workspace/document-production/chroot /usr/bin/dpkg-query -W --showformat='${Status}\n' %s\n" % (package)
            p = pexpect.spawn(cmd)
            p.send("PS1=%s\n" % (prompt)) 
            p.send(cmd)
            
            done = False
            while done == False:
                
                index = p.expect (["install ok installed",
                    "dpkg-query: no packages found matching %s" % (package),
                    prompt, 
                    pexpect.EOF, 
                    pexpect.TIMEOUT],timeout=500)
                self.log.debug("result ddxd=%s`" % (index))
                if index == 0:
                    done = True
                    alreadyinstalled.append(package)
                if index == 1:
                    packagesmissing.append(package)
                    done = True
                if index == 3:
                    done = True
           
            exitstatus = p.exitstatus
            if p.isalive() == True:
                p.send("exit 0\n")
            if p.isalive() == True:
                p.wait()
                
        for package in depnedacylist:
            #self.log.info("ssssssssssssssssssssssssssssssssss")
            cmd = "/usr/sbin/chroot /workspace/document-production/chroot /usr/bin/apt-get install -y --force-yes %s\n" % (package)
            self.log.info(cmd)
            p = pexpect.spawn(cmd)
            p.send("PS1=%s\n" % (prompt)) 
            p.send(cmd)
            done = False
            while done == False:
                index = p.expect (["Do you want to continue",
                    prompt,
                    "%s is already the newest version." % (package),
                    "additional disk space will be used", 
                    pexpect.EOF, 
                    pexpect.TIMEOUT,
                    'Reading package lists',
                    'The following NEW packages will be installed',
                    'Get:.*\r\n',
                    'Selecting previously unselected package',
                    'Fetched',
                    'Unpacking',
                    'Setting',
                    'Processing triggers for ', '\r\n'],
                    timeout=500)
                self.log.info("whatsDaProb=%s" % (index))
                if index == 0:
                    p.send("Y\n")
                    
                if index >= 6:
                    imput = p.before
                    striped = imput.strip()
                    if len(striped) > 0:
                        self.log.info(imput.strip())
                if index in [2,4]:
                    done = True
                if index == 3:
                    p.send("Y\n")
                if index == 1:
                    p.send(cmd)
            if p.isalive() == True:
                p.send("exit 0\n")
            if p.isalive() == True:
                p.wait()
            exitstatus = p.exitstatus
            self.log.error("exit status=%s, cmd=%s" % (exitstatus,cmd))
    
    def packagesScientific(self,jobpart,env):
        self.log.info("packagesScientific(%s,%s)" % (jobpart,env))
        depnedacylist = []
        if "shell" in jobpart.keys():
            
            if "dependancies" in jobpart["shell"].keys():
                
                if "Scientific" in jobpart["shell"]["dependancies"].keys():
                    self.log.info("foundthe answer")
                    depnedacylist = list(jobpart["shell"]["dependancies"]["Scientific"])
        if len(depnedacylist) == 0:
            return True
        
        match_prompt = uuid.uuid1()
        prompt = str(match_prompt)
        packagesmissing = []
        alreadyinstalled = []
        chrootdir = env['CHROOT']
        cmd = "/usr/sbin/chroot %s" % (chrootdir)
        pi = ChrootPackageInstaller(cmd,env)
        initok = pi.initialise()
        if  initok == False:
            return False
        initok = pi.updatePackages()
        if  initok == False:
            return False
        initok = pi.installPackages(depnedacylist)
        if  initok == False:
            return False
        return True
        
        
        
    def packages(self,jobpart,env):
        release =  lsb_release()
        
         
        if release["Distributor ID"] == "Debian":
            self.packagesDebain(jobpart,env)
        
        if release["Distributor ID"] == "Scientific":
            self.packagesScientific(jobpart,env)
          
                    
        
        
    def executabingo(self,jobpart,env = {}):
        self.log.error("executabingo")
        inputenv = os.environ
        inputenv.update(env)
        output = {"rc" :  255 , "env" : {}}
        knownKeys = set(inputenv)
        env_ignored = set(["PATH","SHLVL","OLDPWD",]).union(set(env.keys()))
        
        if not "flags" in jobpart.keys():
            self.log.error("no flags specified")
            return output
        
        if not "script" in jobpart.keys():
            sel.log.error("no script specified")
            return output

        command = "/bin/bash"
        allfliages =  jobpart["flags"]
        self.log.error("flags=%s" % (allfliages))
        if "chroot" in allfliages:
            if not "CHROOT" in inputenv.keys():
                self.log.error("no CHROOT")
                return output
            chootdir = inputenv["CHROOT"]
            command = "%s %s /bin/bash"  % ("/usr/sbin/chroot" , chootdir)
        
        #chroot /workspace/docbook-production/chroot/ /bin/bash
        sr = runnershell(command,env)
        rc = sr.initialise()
        if rc != True:
            sel.log.error("failed to init CHROOT")
            return output
        rc = sr.setEnv(env)
        if rc != True:
            sel.log.error("failed to set env in CHROOT")
            return output
        # Now load script
        script = "%s/%s" % (os.path.dirname(os.path.realpath(__file__)),jobpart["script"])
        initialEnv = sr.getEnv()
        #self.log.info("initialEnv '%s'" % (initialEnv))
        rc = sr.runscript(script)
        afterEnv = sr.getEnv()
        self.log.info("afterEnv '%s'" % (afterEnv))
        keysInitial = set(initialEnv.keys())
        
        keysFinal = set(afterEnv.keys())
        keysnew = keysFinal.difference(keysInitial)
        foundEnv = {}
        for key in keysnew:
            value = afterEnv[key]
            self.log.info("Exported '%s=%s'" % (key,value))
            foundEnv[key] = value
        returnCode = sr.finalise()
        return {"rc" :  returnCode , "env" : foundEnv}

def runJob (jobname):
    log = logging.getLogger("runJob")
    mappings = {
        "GenChroot.SL-6X" : ["transfer/GenChroot.SL-6X.sh"],
        "vmcatcher-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-trunk-test" :["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher-scientific-6-trunk-test.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher-scientific-6-prod-test" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher-scientific-6-prod-test.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        
        "vmcatcher_eventHndlExpl_ON-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcatcher_eventHndlExpl_ON-scientific-6-prod-part-01.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcatcher_eventHndlExpl_ON-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/vmcatcher_eventHndlExpl_ON-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-scientific-6-trunk" :["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/smimeX509validation-scientific-6-trunk-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "smimeX509validation-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/smimeX509validation-scientific-6-prod-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "grid-virt-sort-scientific-6-prod" : [ "transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/grid-virt-sort-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "hepixvmitrust-scientific-6-prod" : [ "transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/hepixvmitrust-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-scientific-6-trunk" : [ "transfer/chroot-scientific-6-buildup-trunk.sh" ,
            "transfer/vmcaster-scientific-6-trunk-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "dirvacua-scientific-6-trunk" : [ "transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/dirvacua-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/vmcaster-scientific-6-prod-part-02.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "chrootbuilder-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/chrootbuilder-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "vmcaster-debian-wheezy-prod" : ["transfer/vmcaster-debian-wheezy-prod-part-01.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-02.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-03.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-04.sh",
            "transfer/vmcaster-debian-wheezy-prod-part-05.sh"],
        "hepixvmitrust-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/hepixvmitrust-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "repo-scientific" : ["transfer/repo-scientific.sh"],
        "hepixvmitrust-debian-wheezy-prod" : ["transfer/hepixvmitrust-debian-wheezy-prod-part-01.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-02.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-03.sh",
            "transfer/hepixvmitrust-debian-wheezy-prod-part-04.sh"],
        "grid-virt-sort-scientific-6-trunk" : ["transfer/chroot-scientific-6-buildup-trunk.sh",
            "transfer/grid-virt-sort-scientific-6-trunk.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "GenChroot.debian-wheezy" : ["transfer/GenChroot.debian-wheezy-part-01.sh",
            "transfer/GenChroot.debian-wheezy-part-02.sh",
            "transfer/GenChroot.debian-wheezy-part-03.sh",
            "transfer/GenChroot.debian-wheezy-part-04.sh"],
        "dirvacua-debian-wheezy-prod" : ["transfer/dirvacua-debian-wheezy-prod-part-01.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-02.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-03.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-04.sh",
            "transfer/dirvacua-debian-wheezy-prod-part-05.sh"],
        "dirvacua-scientific-6-prod" : ["transfer/chroot-scientific-6-buildup-prod.sh",
            "transfer/dirvacua-scientific-6-prod.sh",
            "transfer/chroot-scientific-6-teardown.sh"],
        "chroot-imagelist-update" : ["transfer/chroot-imagelist-update.sh"],
        "chroot-scientific-6-repo" : ["transfer/chroot-scientific-6-repo.sh"],
        "publish-image-overlay" : ["transfer/publish-image-overlay-debian.sh"],
        
        
        "docbook-production" : [{   "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
        
            {   "script" : "transfer/docbook-production.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["make", "subversion","openjdk-6-jre-lib","libservlet2.5-java", "openjdk-6-jre","openjdk-6-jre-headless", "fop", "xsltproc","docbook-xml","docbook-xsl" ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "vmcatcher-debian-wheezy-prod" : [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/vmcatcher-debian-wheezy-prod-part-03.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["git", "python","rpm","make", "python-setuptools","python-m2crypto", ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "smimeX509validation-debian-wheezy-prod": [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/smimeX509validation-debian-wheezy-prod-part-04.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["git", "python","rpm","make", "python-setuptools","python-m2crypto", ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "grid-virt-sort-debian-wheezy-prod-deb": [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/smimeX509validation-debian-wheezy-prod-part-04.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["git", "python","git-buildpackage","devscripts", "python-all",  "python-setuptools","python-m2crypto",] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "grid-virt-sort-debian-wheezy-prod": [{  "script" : "transfer/chroot-debian-wheezy-buildup.sh"},
            {   "script" : "transfer/grid-virt-sort-debian-wheezy-prod-part-03.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Debian" : ["subversion", "python","rpm","make" ] },
                    }
            },
            {   "script" : "transfer/chroot-debian-wheezy-teardown.sh"},
            ],
        "chroot-test-vmcatcher-scientific-6-prod" : [{"script" : "transfer/chroot-scientific-6-buildup-prod.sh"},
            {   "script" : "transfer/chroot-test-vmcatcher-scientific-6-prod.sh",
                "shell" : { "type" : "chroot",
                    "command" : { "template" : "chroot %CHROOT%",
                        "envimeroment" : ["CHROOT"]
                        },
                    "dependancies" :{ "Scientific" : ["hepixvmitrust","git", "python","rpm","make","python-setuptools","m2crypto" ] },
                    },
                "artifacts" : ["artifacts.tgz"],
                "flags" : [],
            },
            {"script" : "transfer/chroot-scientific-6-teardown.sh"}],
        }
    if not jobname in mappings.keys():
        log.error("job is not mapped '%s' " % (jobname) )
        return 1
    enviroment = {}
    for jobpart in mappings[jobname]:
        if type(jobpart) == str:
            log.info("running jobpart '%s' " % (jobpart) )
            script = "%s/%s" % (os.path.dirname(os.path.realpath(__file__)),jobpart)
            cmd = ". %s" % (script)
            processRc,stdout,stderr = subphandling(cmd,timeout = 360)
            log.info(" '%s' " % (processRc) )
            if processRc != 0:
                log.error("cmd '%s' returned '%s'." % (cmd,processRc) )
                return processRc
        if type(jobpart) == dict:
            foo = jobPartRun()
            #requires = set(jobpart["requires"])
            log.info("running jobpart '%s' " % (jobpart))
            if not "flags" in jobpart.keys():
                jobpart["flags"] = []
            resetMap = foo.executabingo(jobpart,enviroment)
            if resetMap["env"] != 0:
                enviroment.update(resetMap["env"])
                log.info("Job Enviroment='%s'" % (enviroment) )
            if resetMap["rc"] != 0:
                log.error("cmd '%s' returned '%s'." % (cmd,resetMap["rc"]))
                return resetMap["rc"]
            rc = foo.getArtifacts(jobpart,enviroment)
            if rc != True:
                return rc
    return 0
        
        




def main():
    reload(sys)
    sys.setdefaultencoding('utf-8')
    log = logging.getLogger("main")
    p = optparse.OptionParser(version = "%prog " + "0.0.1")
    p.add_option('--verbose', action ='count',help='Change global log level, increasing log output.', metavar='LOGFILE')
    p.add_option('--quiet', action ='count',help='Change global log level, decreasing log output.', metavar='LOGFILE')
    p.add_option('--log-config', action ='store',help='Logfile configuration file, (overrides command line).', metavar='LOGFILE')
    p.add_option('--logcfg', action ='store',help='Logfile configuration file.', metavar='LOGCFGFILE')
    
    options, arguments = p.parse_args()
    if options.logcfg:
        if os.path.isfile(str(options.logfile)):
            logging.config.fileConfig(options.logfile)
        else:
            logging.basicConfig(level=logging.INFO)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.logfile))
            sys.exit(1)
    else:
        logging.basicConfig(level=logging.INFO)
    outputDict = None
    logFile = None
    
    if 'VMCHNDL_ON_LOG_CONF' in os.environ:
        logFile = os.environ['VMCHNDL_ON_LOG_CONF']
    # Set up log file
    LoggingLevel = logging.WARNING
    LoggingLevelCounter = 2
    if options.verbose:
        LoggingLevelCounter = LoggingLevelCounter - options.verbose
        if options.verbose == 1:
            LoggingLevel = logging.INFO
        if options.verbose == 2:
            LoggingLevel = logging.DEBUG
    if options.quiet:
        LoggingLevelCounter = LoggingLevelCounter + options.quiet
    if LoggingLevelCounter <= 0:
        LoggingLevel = logging.DEBUG
    if LoggingLevelCounter == 1:
        LoggingLevel = logging.INFO
    if LoggingLevelCounter == 2:
        LoggingLevel = logging.WARNING
    if LoggingLevelCounter == 3:
        LoggingLevel = logging.ERROR
    if LoggingLevelCounter == 4:
        LoggingLevel = logging.FATAL
    if LoggingLevelCounter >= 5:
        LoggingLevel = logging.CRITICAL
    
    if options.log_config:
        logFile = options.log_config
    if logFile != None:
        if os.path.isfile(str(options.log_config)):
            logging.config.fileConfig(options.log_config)
        else:
            logging.basicConfig(level=LoggingLevel)
            log = logging.getLogger("main")
            log.error("Logfile configuration file '%s' was not found." % (options.log_config))
            sys.exit(1)
    else:
        logging.basicConfig(level=LoggingLevel)
    log = logging.getLogger("main")

    jobname = None
    if 'JOB_NAME' in os.environ:
        jobname=os.environ['JOB_NAME']
    else:
        log.error("No JOB_NAME Enviroment variable set")
        sys.exit(2)
    log.info("JOB_NAME=%s" % jobname )
    
    rc = runJob(jobname)
    if rc != 0:
        log.error("runJob returned '%s'" % (rc) )
        sys.exit(2)
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    main()
